from __future__ import annotations
__all__ = ["Axes3D", "_Quaternion", "get_test_data"]

from typing import Any, List, Optional, Sequence, Tuple, Union

import numpy as np
import numpy.typing as npt

from matplotlib.axes import Axes
from matplotlib.artist import Artist
from matplotlib.figure import Figure
from matplotlib.transforms import Bbox


Number = Union[int, float, np.ndarray]
ArrayLike = npt.ArrayLike


class Axes3D(Axes):
    name: str
    initial_azim: float
    initial_elev: float
    initial_roll: float
    computed_zorder: bool
    M: Optional[np.ndarray]
    invM: Optional[np.ndarray]

    def __init__(
        self,
        fig: Figure,
        rect: Optional[Tuple[float, float, float, float]] = ...,
        *args: Any,
        elev: float = ..., azim: float = ..., roll: float = ...,
        shareview: Optional["Axes3D"] = ..., sharez: Optional["Axes3D"] = ...,
        proj_type: str = ..., focal_length: Optional[float] = ...,
        box_aspect: Optional[Sequence[float]] = ..., computed_zorder: bool = ...,
        **kwargs: Any,
    ) -> None: ...

    # axis control
    def set_axis_off(self) -> None: ...
    def set_axis_on(self) -> None: ...

    def convert_zunits(self, z: Any) -> Any: ...

    def set_top_view(self) -> None: ...

    def get_zaxis(self) -> Any: ...

    def view_init(self, elev: Optional[float] = ..., azim: Optional[float] = ...,
                  roll: Optional[float] = ..., vertical_axis: str = ..., share: bool = ...) -> None: ...

    def set_proj_type(self, proj_type: str, focal_length: Optional[float] = None) -> None: ...

    def get_proj(self) -> np.ndarray: ...

    def mouse_init(self, rotate_btn: int = ..., pan_btn: int = ..., zoom_btn: int = ...) -> None: ...

    def disable_mouse_rotation(self) -> None: ...

    def can_zoom(self) -> bool: ...

    def can_pan(self) -> bool: ...

    def sharez(self, other: "Axes3D") -> None: ...

    def shareview(self, other: "Axes3D") -> None: ...

    def clear(self) -> None: ...

    def format_zdata(self, z: Any) -> str: ...

    def format_coord(self, xv: float, yv: float, renderer: Optional[Any] = ...) -> str: ...

    def plot(self, xs: ArrayLike, ys: ArrayLike, *args: Any, zdir: str = ..., axlim_clip: bool = ..., **kwargs: Any) -> List[Artist]: # type: ignore[override]
        ...

    plot3D = plot

    def plot_surface(self, X: ArrayLike, Y: ArrayLike, Z: ArrayLike, *,
                     norm: Optional[Any] = ..., vmin: Optional[float] = ...,
                     vmax: Optional[float] = ..., lightsource: Optional[Any] = ...,
                     axlim_clip: bool = ..., **kwargs: Any) -> Artist: ...

    def plot_wireframe(self, X: ArrayLike, Y: ArrayLike, Z: ArrayLike, *, axlim_clip: bool = ..., **kwargs: Any) -> Artist: ...

    def plot_trisurf(self, *args: Any, color: Optional[Any] = ..., norm: Optional[Any] = ...,
                     vmin: Optional[float] = ..., vmax: Optional[float] = ...,
                     lightsource: Optional[Any] = ..., axlim_clip: bool = ..., **kwargs: Any) -> Artist: ...

    def add_collection3d(self, col: Any, zs: Number = ..., zdir: str = ..., autolim: bool = ..., *, axlim_clip: bool = ...) -> None: ...

    def scatter(self, xs: ArrayLike, ys: ArrayLike, zs: Optional[Union[ArrayLike, float, int]] = ..., *,
                s: Optional[ArrayLike] = ..., c: Optional[Any] = ..., **kwargs: Any) -> Artist: # type: ignore[override]
         ...

    scatter3D = scatter

    def voxels(self, *args: Any, facecolors: Optional[Any] = ..., edgecolors: Optional[Any] = ..., shade: bool = ..., lightsource: Optional[Any] = ..., axlim_clip: bool = ..., **kwargs: Any) -> Any: ...

    def set_title(self, label: str, fontdict: Optional[dict] = ..., loc: str = ..., **kwargs: Any) -> None: # type: ignore[override]
        ...

    def set_zlabel(self, zlabel: Any, fontdict: Optional[dict] = ..., labelpad: Optional[float] = ..., **kwargs: Any) -> Any: ...

    def get_zlabel(self) -> Any: ...

    def grid(self, visible: bool = True, **kwargs: Any) -> None: # type: ignore[override]
        ...

    def tick_params(self, axis: Union[str, int] = 'both', **kwargs: Any) -> None: ...

    def invert_zaxis(self) -> None: ...

    def get_zbound(self) -> Tuple[float, float]: ...

    def text(self, x: float, y: float, z: float, s: str, zdir: Optional[Union[str, tuple]] = ..., *, axlim_clip: bool = ..., **kwargs: Any) -> Artist: # type: ignore[override] 
        ...

    text3D = text

    def add_contour_set(self, cset: Any, extend3d: bool = ..., stride: int = ..., zdir: str = ..., offset: Optional[float] = ..., axlim_clip: bool = ...) -> None: ...

    def contour(self, *args: Any, **kwargs: Any) -> Any: ...
    contour3D = contour

    def contourf(self, *args: Any, **kwargs: Any) -> Any: ...
    contourf3D = contourf

    def get_tightbbox(self, renderer: Optional[Any] = ..., *, call_axes_locator: bool = ..., bbox_extra_artists: Optional[Sequence[Artist]] = ..., for_layout_only: bool = ...) -> Optional[Bbox]: ...


def get_test_data(delta: float = 0.05) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    ...


class _Quaternion:
    scalar: float
    vector: np.ndarray

    def __init__(self, scalar: float, vector: ArrayLike) -> None: ...

    def __neg__(self) -> "_Quaternion": ...

    def __mul__(self, other: "_Quaternion") -> "_Quaternion": ...

    def conjugate(self) -> "_Quaternion": ...

    @property
    def norm(self) -> float: ...

    def normalize(self) -> "_Quaternion": ...

    def reciprocal(self) -> "_Quaternion": ...

    def __truediv__(self, other: "_Quaternion") -> "_Quaternion": ...

    def rotate(self, v: ArrayLike) -> np.ndarray: ...

    def __eq__(self, other: object) -> bool: ...

    def __repr__(self) -> str: ...

    @classmethod
    def rotate_from_to(cls, r1: ArrayLike, r2: ArrayLike) -> "_Quaternion": ...

    @classmethod
    def from_cardan_angles(cls, elev: float, azim: float, roll: float) -> "_Quaternion": ...

    def as_cardan_angles(self) -> Tuple[float, float, float]: ...
