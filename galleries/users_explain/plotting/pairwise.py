"""
.. _plotting_pairwise:

Pairwise data
=============

The most common plot type is a simple y versus x plot.  Typically we
will have arrays :math:`x_i` and :math:`y_i` of equal size that we want to plot
against each other.
"""

import matplotlib.pyplot as plt
import numpy as np

plt.rcParams['figure.constrained_layout.use'] = True
plt.rcParams['figure.figsize'] = (5, 4)


# %%
#
# plot
# ----
#
# The most simple way to plot x and y data versus each other is to use the
# `~.Axes.plot` method.

x = np.linspace(-2 * np.pi, 2 * np.pi, 30)
y = np.sinc(x)

fig, ax = plt.subplots()
ax.plot(x, y)
ax.set_xlabel('x')
ax.set_ylabel('sinc(x)')

# %%
# By default, `~.Axes.plot` joins data points with a solid straight line, as
# shown in the jagged nature of the plot above. We can style that line,
# with dashes, plot the data with symbols, or both styles, as demonstrated below.

fig, axs = plt.subplots(3, 1, sharex=True)
ax = axs[0]
ax.plot(x, y, '--')
ax.set_ylabel('sinc(x)')
ax = axs[1]
ax.plot(x, y, 'd')
ax = axs[2]
ax.plot(x, y, 'd--')
ax.set_xlabel('x')

# %%
# Multiple datasets can be plotted simultaneously against a single ``x`` array
# if the shape of ``Y`` is compatible. In this example, ``Y`` has the shape ``(30, 3)``,
# meaning each column has the same length as ``x``.
# Each column in ``Y`` is assigned a different color according to the
# default :ref:`color cycle <color_cycle>`. A legend for each column in
# ``Y`` is generated by providing a **label** with a list of column names:

Y = np.arange(30*3).reshape(3, 30).T
fig, ax = plt.subplots(figsize=(5, 3))
ax.plot(x, Y, label=['column 1', 'column 2', 'column 3'])
ax.legend()
ax.set_xlabel('x')

# %%
# fill_between, fill_betweenx, and stackplot
# -----------------------------------------
#
# The `~.Axes.fill_between` method is useful to indicate a confidence interval
# around a line plot. In this example, the confidence interval is imagined to
# grow with distance in the x direction from the origin, but typically this
# would be based on data. `~.Axes.fill_betweenx` does the same thing but for
# the y direction.

fig, axs = plt.subplots(1, 2)
ax = axs[0]
ax.plot(x, y)
ax.set_title("fill_between")
ax.fill_between(x, y - np.abs(x) / 20, y + np.abs(x) / 20, color='C0', alpha=0.5)
ax.set_ylabel('x')
ax.set_xlabel('sinc(x)')

ax = axs[1]
ax.plot(y, x)
ax.set_title("fill_betweenx")
ax.fill_betweenx(x, y - np.abs(x) / 20, y + np.abs(x) / 20, color='C0', alpha=0.5)
ax.set_ylabel('y')
ax.set_xlabel('sinc(y)')

# %%
# `~.Axes.fill_between` can also be used to fill between two lines, and can
# have conditions set on when to fill.  Here we fill between two lines where
# the condition is met that the line with the larger y value is above the line
# with the smaller y value.  The *where* keyword is used to set this condition.
# The *interpolate* keyword is used to linearly interpolate the fill to
# where the condition is just met.
#

fig, ax = plt.subplots()
ax.plot(x, y, label='sinc(x)')
y2 = 2.0 * np.sinc(x + 0.3)
ax.plot(x, y2, label='2.0 sinc(x + 0.3)')
ax.fill_between(x, y, y2, where=(y >= y2), color='C0', alpha=0.3, interpolate=True)
ax.fill_between(x, y, y2, where=(y < y2), color='C1', alpha=0.3, interpolate=True)
ax.legend()
ax.set_xlabel('x')
ax.set_ylabel('sinc(x)')
ax.set_title("fill_between with condition")

# %%
# .. seealso::
#   :ref:`fill_between_demo` for more `~.Axes.fill_between` examples.
#
# `~.Axes.stackplot` is useful for plotting series of data that stack on top of
# each other, often when the data represents a sum of different components.
# Here we plot three series of data and then that we then sum them up in the stackplot.

fig, axs = plt.subplots(2, 1)
rng = np.random.default_rng(seed=19680801)

data = rng.random(size=(30, 3))
x = np.arange(30)
ax = axs[0]
ax.plot(x, data, label=['A', 'B', 'C'])
ax.legend()
ax.set_ylabel('data')
ax = axs[1]
ax.stackplot(x, data.cumsum(axis=1).T, labels=['A', 'A+B', 'A+B+C'], alpha=0.8)
ax.legend()
ax.set_xlabel('x')
ax.set_ylabel('stacked data')
ax.set_title("stackplot")

# %%
# errorbar
# --------
#
# Confidence intervals in both x and y can be shown using the `~.Axes.errorbar` method.
# The `~.Axes.errorbar` method has many options to control the appearance of the plot.
# The error bars can be specified as a scalar or as an array for each data point.

x = np.linspace(0, 10, 50)
dy = 0.8
y = np.sin(x) + dy * np.random.randn(50)
errx = 0.2 + np.random.rand(50) / 3
erry = 0.2 + np.random.rand(50) / 3

fig, ax = plt.subplots()
ax.errorbar(x, y, xerr=errx, yerr=erry, fmt='o')

ax.set_title("errorbar")
ax.set_xlabel("x")
ax.set_ylabel("sin(x) plus noise")

# %%
#
# `~.Axes.errorbar` inherits from `~.Axes.plot`, allowing the use of the same
# format to control the marker's appearance. The appearance of error bars is
# controlled by keyword arguments such as *ecolor* for the color of the error
# bar lines, **capsize** for the length of the error bar caps, and *elinewidth*
# for the thickness of the error bar lines. Error bars can also be asymmetric
# if *yerr* or *xerr* are provided as 2D arrays.

fig, ax = plt.subplots()
ax.errorbar(x, y, yerr=[erry, 2*erry], xerr=[errx, 2*errx], fmt='o',
            ecolor='lightgray', elinewidth=2, capsize=5)
ax.set_title("Asymmetric error bars")
ax.set_xlabel("x")
ax.set_ylabel("sin(x) plus noise")
# %%
#
# scatter
# -------
#
# The `~.Axes.scatter` method is similar to `~.Axes.plot` in that it plots two
# arrays of data against each other, but differs in the following ways:
#
# * there is no option to connect markers with lines,
# * the size and color of markers can vary according to the values of other data arrays.
#
# This example demonstrates how to create a scatter plot with varying point sizes using
# the *s* keyword and and colors using the *c* keyword.

y = np.sin(x)

sizes = np.linspace(20, 200, len(x))  # Varying point sizes
colors = y  # Use y-values to map to color

fig, ax = plt.subplots()
scatter = ax.scatter(x, y, c=colors, s=sizes, cmap='viridis', alpha=0.6,
                     edgecolor='black')
ax.set_title("Scatter Plot using scatter()")
ax.set_xlabel("x")
ax.set_ylabel("sin(x)")
fig.colorbar(scatter, label="Value of sin(x)")

#######################################################################################
# The marker style can be changed (see :mod:`matplotlib.markers` for a full
# list), but each call to `~.Axes.scatter` can only accept one *marker* type.
# To code data by different marker shapes, make multiple calls to
# `~.Axes.scatter`.

y2 = np.cos(x)
colors2 = y2

fig, ax = plt.subplots()
# Two scatter calls, one for each data set:
scatter = ax.scatter(x, y, c=colors, s=36, cmap='YlGn_r', alpha=0.6,
                     edgecolor='black', label='sin(x)')
scatter2 = ax.scatter(x, y2, marker='d', c=colors2, s=36, cmap='RdBu_r',
                      alpha=0.6, edgecolor='black', label='cos(x)')

ax.set_title("Coding by marker type")
ax.set_xlabel("x")
ax.set_facecolor('0.8')
ax.legend(fontsize='small')
ax.set_ylabel("sin(x), cos(x)")

# add some colorbars below plot
cax1 = ax.inset_axes([0.05, -0.25, 0.4, 0.05])
fig.colorbar(scatter2, cax=cax1, label="Value of cos(x)", location='bottom')
cax2 = ax.inset_axes([0.55, -0.25, 0.4, 0.05])
fig.colorbar(scatter, cax=cax2, label="Value of sin(x)", location='bottom')


# %%
# bar and stem
# ------------
#
# `~.Axes.bar`, `~.Axes.stairs`, and `~.Axes.stem` are useful for plotting data
# that deviates from a zero or mean value. These methods are often used to plot
# histograms.

x = x[::2]
y = y[::2]
fig, axs = plt.subplots(1, 2, sharex=True, sharey=True)

ax = axs[0]
# need to specify a width so the bars don't overlap.
ax.bar(x, y, width=0.8*np.median(np.diff(x)))
ax.set_title("bar")
ax.set_xlabel('x')

ax = axs[1]
ax.stem(x, y)
ax.set_title("stem")
ax.set_xlabel('x')
ax.set_ylabel('sin(x)')

# %%
# `~.Axes.bar` does not automatically calculate the *width* of the bars, so it
# typically needs to be calculated manually to achieve the correct spacing. The *width*
# can also be specified as an array with the same length as *x* to set the width of each
# bar individually.

fig, ax = plt.subplots()
width = np.concatenate(([np.diff(x)[0]], np.diff(x)))
ax.bar(x, y, width=width * 0.8)
ax.set_title("bar with widths")

# %%
# step and stairs
# ---------------
#
# `~.Axes.step` and `~.Axes.stairs` are similar to `~.Axes.plot` but plot a
# step between each data point. They accept differently shaped data depending
# on the use case.
#
# `~.Axes.step` particularly useful as it accepts the same data shape as
# `~.Axes.plot`.

fig, ax = plt.subplots()

ax.plot(x, y, '-o', color='gray', alpha=0.5)
ax.step(x, y)
ax.set_ylabel('sin(x)')
ax.set_title('step')

# %%

# The steps can be centered on the data in different ways using the **where**
# keyword. The default is **where='pre'**, which means the step extends to the
# left of the data point. **where='mid'** means the step extends halfway to the
# next data point, and **where='post'** means the step extends to the right of
# the data point:

fig, axs = plt.subplots(3, 1, sharex=True, sharey=True, figsize=(4.5, 5))

todo = ['pre', 'mid', 'post']
for ax, where in zip(axs, todo):
    ax.plot(x, y, '-o', color='gray', alpha=0.5)
    ax.step(x, y, where=where)
    ax.set_title(f'step where={where}')

# %%
# .. seealso::
#   :ref:`step_demo` for more step examples.

# %%
#
# `~.Axes.stairs` is useful for plotting histograms, and specifies the edges of
# steps rather than the centers, so  can directly be used with the result from
# `~numpy.histogram`.

data = rng.normal(size=1000)
hist, bin_edges = np.histogram(data, bins=np.arange(-4, 4, 0.2), density=True)

data2 = rng.uniform(low=-4, high=4, size=300)
hist2, bin_edges2 = np.histogram(data2, bins=np.arange(-4, 4, 0.4), density=True)

fig, ax = plt.subplots()
ax.stairs(hist, bin_edges, fill=True, alpha=0.4, orientation='vertical',
          label='normal')

ax.stairs(hist2, bin_edges2, fill=True, alpha=0.4, orientation='vertical',
          label='uniform')
ax.set_title('stairs from histogram')
ax.set_xlabel('data')
ax.set_ylabel('probability density function')
ax.legend()

# %%
# .. admonition:: References
#
#   The use of the following functions, methods, classes and modules is shown
#   in this example:
#
#   - `matplotlib.axes.Axes.plot` / `matplotlib.pyplot.plot`
#   - `matplotlib.axes.Axes.fill_between` / `matplotlib.pyplot.fill_between`
#   - `matplotlib.axes.Axes.fill_betweenx` / `matplotlib.pyplot.fill_betweenx`
#   - `matplotlib.axes.Axes.stackplot` / `matplotlib.pyplot.stackplot`
#   - `matplotlib.axes.Axes.errorbar` / `matplotlib.pyplot.errorbar`
#   - `matplotlib.axes.Axes.scatter` / `matplotlib.pyplot.scatter`
#   - `matplotlib.axes.Axes.bar` / `matplotlib.pyplot.bar`
#   - `matplotlib.axes.Axes.stem` / `matplotlib.pyplot.stem`
#   - `matplotlib.axes.Axes.step` / `matplotlib.pyplot.step`
#   - `matplotlib.axes.Axes.stairs` / `matplotlib.pyplot.stairs`
#   - `matplotlib.figure.Figure.colorbar`
